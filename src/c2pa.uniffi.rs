// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// Unit struct to parameterize the FfiConverter trait.
//
// We use FfiConverter<UniFfiTag> to handle lowering/lifting/serializing types for this crate.  See
// https://mozilla.github.io/uniffi-rs/internals/lifting_and_lowering.html#code-generation-and-the-fficonverter-trait
// for details.
//
// This is pub, since we need to access it to support external types
#[doc(hidden)]
pub struct UniFfiTag;

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_c2pa_uniffi_contract_version() -> u32 {
    22
}
/// Export namespace metadata.
///
/// See `uniffi_bindgen::macro_metadata` for how this is used.


#[::uniffi::ffi_converter_error(
    tag = crate::UniFfiTag,
    
    handle_unknown_callback_error,
)]
enum r#Error {
    r#Assertion { r#reason: String },
    r#AssertionNotFound { r#reason: String },
    r#Decoding { r#reason: String },
    r#Encoding { r#reason: String },
    r#FileNotFound { r#reason: String },
    r#Io { r#reason: String },
    r#Json { r#reason: String },
    r#Manifest { r#reason: String },
    r#ManifestNotFound { r#reason: String },
    r#NotSupported { r#reason: String },
    r#Other { r#reason: String },
    r#RemoteManifest { r#reason: String },
    r#ResourceNotFound { r#reason: String },
    r#RwLock {},
    r#Signature { r#reason: String },
    r#Verify { r#reason: String },
}

// Enum definitions, corresponding to `enum` in UDL.

#[::uniffi::ffi_converter_enum(tag = crate::UniFfiTag)]
enum r#SeekMode {
    r#Start {},
    r#End {},
    r#Current {},
}

// Enum definitions, corresponding to `enum` in UDL.

#[::uniffi::ffi_converter_enum(tag = crate::UniFfiTag)]
enum r#SigningAlg {
    r#Es256 {},
    r#Es384 {},
    r#Es512 {},
    r#Ps256 {},
    r#Ps384 {},
    r#Ps512 {},
    r#Ed25519 {},
}

// Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.

// Top level functions, corresponding to UDL `namespace` functions.

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_func_version(
    call_status: &mut uniffi::RustCallStatus,
) -> <String as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("uniffi_c2pa_fn_func_version");
    uniffi::rust_call(call_status, || {
        <String as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(r#version())
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_func_sdk_version(
    call_status: &mut uniffi::RustCallStatus,
) -> <String as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    // If the provided function does not match the signature specified in the UDL
    // then this attempt to call it will not compile, and will give guidance as to why.
    uniffi::deps::log::debug!("uniffi_c2pa_fn_func_sdk_version");
    uniffi::rust_call(call_status, || {
        <String as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(r#sdk_version())
    })
}
// Object definitions, corresponding to UDL `interface` definitions.

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.
#[::uniffi::ffi_converter_interface(tag = crate::UniFfiTag)]
struct r#Reader {}

// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#Reader: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn uniffi_c2pa_fn_free_reader(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::rust_call(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { ::std::sync::Arc::from_raw(ptr as *const r#Reader) });

        Ok(())
    })
}
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn r#uniffi_c2pa_fn_constructor_reader_new(
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void /* *const Reader */ {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_constructor_reader_new");

    // If the constructor does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.
    uniffi::rust_call(call_status, || {
        <std::sync::Arc<r#Reader> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            ::std::sync::Arc::new(r#Reader::r#new()),
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_reader_from_stream(
    r#ptr: *const std::os::raw::c_void,
    r#format: ::uniffi::RustBuffer,
    r#reader: u64,
    call_status: &mut uniffi::RustCallStatus,
) -> <String as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_reader_from_stream");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<String, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Reader>::r#from_stream(
        match<std::sync::Arc<r#Reader> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#format) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "format")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#reader) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "reader")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_reader_from_manifest_data_and_stream(
    r#ptr: *const std::os::raw::c_void,
    r#manifest_data: ::uniffi::RustBuffer,
    r#format: ::uniffi::RustBuffer,
    r#reader: u64,
    call_status: &mut uniffi::RustCallStatus,
) -> <String as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_reader_from_manifest_data_and_stream");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<String, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Reader>::r#from_manifest_data_and_stream(
        match<std::sync::Arc<r#Reader> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#manifest_data) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "manifest_data")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#format) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "format")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#reader) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "reader")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_reader_json(
    r#ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) -> <String as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_reader_json");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<String, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Reader>::r#json(
        match<std::sync::Arc<r#Reader> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_reader_resource_to_stream(
    r#ptr: *const std::os::raw::c_void,
    r#uri: ::uniffi::RustBuffer,
    r#stream: u64,
    call_status: &mut uniffi::RustCallStatus,
) -> <u64 as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_reader_resource_to_stream");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<u64, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Reader>::r#resource_to_stream(
        match<std::sync::Arc<r#Reader> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#uri) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "uri")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#stream) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "stream")),
        })
    
            .map_err(Into::into)
        )
    })
}

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.
#[::uniffi::ffi_converter_interface(tag = crate::UniFfiTag)]
struct r#CallbackSigner {}

// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#CallbackSigner: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn uniffi_c2pa_fn_free_callbacksigner(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::rust_call(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { ::std::sync::Arc::from_raw(ptr as *const r#CallbackSigner) });

        Ok(())
    })
}
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn r#uniffi_c2pa_fn_constructor_callbacksigner_new(
    r#callback: u64,
    r#alg: ::uniffi::RustBuffer,
    r#certs: ::uniffi::RustBuffer,
    r#ta_url: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void /* *const CallbackSigner */ {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_constructor_callbacksigner_new");

    // If the constructor does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.
    uniffi::rust_call(call_status, || {
        <std::sync::Arc<r#CallbackSigner> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
                ::std::sync::Arc::new(r#CallbackSigner::r#new(
        match<Box<dyn r#SignerCallback> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#callback) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "callback", err),
        },
        match<r#SigningAlg as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#alg) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "alg", err),
        },
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#certs) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "certs", err),
        },
        match<std::option::Option<String> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ta_url) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "ta_url", err),
        }))
            )
    })
}
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn r#uniffi_c2pa_fn_constructor_callbacksigner_new_from_signer(
    r#callback: u64,
    r#alg: ::uniffi::RustBuffer,
    r#reserve_size: u32,
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void /* *const CallbackSigner */ {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_constructor_callbacksigner_new_from_signer");

    // If the constructor does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.
    uniffi::rust_call(call_status, || {
        <std::sync::Arc<r#CallbackSigner> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
                ::std::sync::Arc::new(r#CallbackSigner::r#new_from_signer(
        match<Box<dyn r#SignerCallback> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#callback) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "callback", err),
        },
        match<r#SigningAlg as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#alg) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "alg", err),
        },
        match<u32 as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#reserve_size) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "reserve_size", err),
        }))
            )
    })
}

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.
#[::uniffi::ffi_converter_interface(tag = crate::UniFfiTag)]
struct r#Builder {}

// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#Builder: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn uniffi_c2pa_fn_free_builder(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::rust_call(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { ::std::sync::Arc::from_raw(ptr as *const r#Builder) });

        Ok(())
    })
}
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn r#uniffi_c2pa_fn_constructor_builder_new(
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void /* *const Builder */ {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_constructor_builder_new");

    // If the constructor does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.
    uniffi::rust_call(call_status, || {
        <std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            ::std::sync::Arc::new(r#Builder::r#new()),
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_with_json(
    r#ptr: *const std::os::raw::c_void,
    r#json: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_with_json");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<(), r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#with_json(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#json) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "json")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_set_no_embed(
    r#ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_set_no_embed");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<(), r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#set_no_embed(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_set_remote_url(
    r#ptr: *const std::os::raw::c_void,
    r#url: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_set_remote_url");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<(), r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#set_remote_url(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#url) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "url")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_add_resource(
    r#ptr: *const std::os::raw::c_void,
    r#uri: ::uniffi::RustBuffer,
    r#stream: u64,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_add_resource");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<(), r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#add_resource(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#uri) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "uri")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#stream) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "stream")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_add_ingredient(
    r#ptr: *const std::os::raw::c_void,
    r#ingredient_json: ::uniffi::RustBuffer,
    r#format: ::uniffi::RustBuffer,
    r#stream: u64,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_add_ingredient");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<(), r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#add_ingredient(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ingredient_json) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ingredient_json")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#format) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "format")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#stream) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "stream")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_to_archive(
    r#ptr: *const std::os::raw::c_void,
    r#stream: u64,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_to_archive");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<(), r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#to_archive(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#stream) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "stream")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_from_archive(
    r#ptr: *const std::os::raw::c_void,
    r#stream: u64,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_from_archive");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<(), r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#from_archive(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#stream) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "stream")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_sign(
    r#ptr: *const std::os::raw::c_void,
    r#signer: *const std::os::raw::c_void,
    r#format: ::uniffi::RustBuffer,
    r#input: u64,
    r#output: u64,
    call_status: &mut uniffi::RustCallStatus,
) -> <Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_sign");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<Vec<u8>, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#sign(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<std::sync::Arc<r#CallbackSigner> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#signer) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "signer")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#format) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "format")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#input) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "input")),
        },
        match<Box<dyn r#Stream> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#output) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "output")),
        })
    
            .map_err(Into::into)
        )
    })
}

#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value, clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_c2pa_fn_method_builder_sign_file(
    r#ptr: *const std::os::raw::c_void,
    r#signer: *const std::os::raw::c_void,
    r#input: ::uniffi::RustBuffer,
    r#output: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> <Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    uniffi::deps::log::debug!("uniffi_c2pa_fn_method_builder_sign_file");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<Vec<u8>, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Builder>::r#sign_file(
        match<std::sync::Arc<r#Builder> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<std::sync::Arc<r#CallbackSigner> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#signer) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "signer")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#input) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "input")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#output) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "output")),
        })
    
            .map_err(Into::into)
        )
    })
}

// Callback Interface definitions, corresponding to UDL `callback interface` definitions.

// Register a foreign callback for getting across the FFI.
#[doc(hidden)]
static FOREIGN_CALLBACK_STREAM_INTERNALS: uniffi::ForeignCallbackInternals =
    uniffi::ForeignCallbackInternals::new();

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn uniffi_c2pa_fn_init_callback_stream(
    callback: uniffi::ForeignCallback,
    _: &mut uniffi::RustCallStatus,
) {
    FOREIGN_CALLBACK_STREAM_INTERNALS.set_callback(callback);
    // The call status should be initialized to CALL_SUCCESS, so no need to modify it.
}

// Make an implementation which will shell out to the foreign language.
#[doc(hidden)]
#[derive(Debug)]
struct UniFFICallbackHandlerStream {
    handle: u64,
}

impl UniFFICallbackHandlerStream {
    fn new(handle: u64) -> Self {
        Self { handle }
    }
}

impl Drop for UniFFICallbackHandlerStream {
    fn drop(&mut self) {
        FOREIGN_CALLBACK_STREAM_INTERNALS.invoke_callback::<(), crate::UniFfiTag>(
            self.handle,
            uniffi::IDX_CALLBACK_FREE,
            Default::default(),
        )
    }
}

uniffi::deps::static_assertions::assert_impl_all!(UniFFICallbackHandlerStream: Send);

impl r#Stream for UniFFICallbackHandlerStream {
    fn r#read_stream(&self, r#length: u64) -> ::std::result::Result<Vec<u8>, r#Error> {
        let mut args_buf = Vec::new();

        <u64 as ::uniffi::FfiConverter<crate::UniFfiTag>>::write(r#length, &mut args_buf);
        let args_rbuf = uniffi::RustBuffer::from_vec(args_buf);
        FOREIGN_CALLBACK_STREAM_INTERNALS
            .invoke_callback::<::std::result::Result<Vec<u8>, r#Error>, crate::UniFfiTag>(
                self.handle,
                1,
                args_rbuf,
            )
    }
    fn r#seek_stream(&self, r#pos: i64, r#mode: r#SeekMode) -> ::std::result::Result<u64, r#Error> {
        let mut args_buf = Vec::new();

        <i64 as ::uniffi::FfiConverter<crate::UniFfiTag>>::write(r#pos, &mut args_buf);
        <r#SeekMode as ::uniffi::FfiConverter<crate::UniFfiTag>>::write(r#mode, &mut args_buf);
        let args_rbuf = uniffi::RustBuffer::from_vec(args_buf);
        FOREIGN_CALLBACK_STREAM_INTERNALS
            .invoke_callback::<::std::result::Result<u64, r#Error>, crate::UniFfiTag>(
                self.handle,
                2,
                args_rbuf,
            )
    }
    fn r#write_stream(&self, r#data: Vec<u8>) -> ::std::result::Result<u64, r#Error> {
        let mut args_buf = Vec::new();

        <Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::write(r#data, &mut args_buf);
        let args_rbuf = uniffi::RustBuffer::from_vec(args_buf);
        FOREIGN_CALLBACK_STREAM_INTERNALS
            .invoke_callback::<::std::result::Result<u64, r#Error>, crate::UniFfiTag>(
                self.handle,
                3,
                args_rbuf,
            )
    }
}

::uniffi::ffi_converter_callback_interface!(
    r#Stream,
    UniFFICallbackHandlerStream,
    "Stream",
    crate::UniFfiTag
);

// Register a foreign callback for getting across the FFI.
#[doc(hidden)]
static FOREIGN_CALLBACK_SIGNERCALLBACK_INTERNALS: uniffi::ForeignCallbackInternals =
    uniffi::ForeignCallbackInternals::new();

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn uniffi_c2pa_fn_init_callback_signercallback(
    callback: uniffi::ForeignCallback,
    _: &mut uniffi::RustCallStatus,
) {
    FOREIGN_CALLBACK_SIGNERCALLBACK_INTERNALS.set_callback(callback);
    // The call status should be initialized to CALL_SUCCESS, so no need to modify it.
}

// Make an implementation which will shell out to the foreign language.
#[doc(hidden)]
#[derive(Debug)]
struct UniFFICallbackHandlerSignerCallback {
    handle: u64,
}

impl UniFFICallbackHandlerSignerCallback {
    fn new(handle: u64) -> Self {
        Self { handle }
    }
}

impl Drop for UniFFICallbackHandlerSignerCallback {
    fn drop(&mut self) {
        FOREIGN_CALLBACK_SIGNERCALLBACK_INTERNALS.invoke_callback::<(), crate::UniFfiTag>(
            self.handle,
            uniffi::IDX_CALLBACK_FREE,
            Default::default(),
        )
    }
}

uniffi::deps::static_assertions::assert_impl_all!(UniFFICallbackHandlerSignerCallback: Send);

impl r#SignerCallback for UniFFICallbackHandlerSignerCallback {
    fn r#sign(&self, r#data: Vec<u8>) -> ::std::result::Result<Vec<u8>, r#Error> {
        let mut args_buf = Vec::new();

        <Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::write(r#data, &mut args_buf);
        let args_rbuf = uniffi::RustBuffer::from_vec(args_buf);
        FOREIGN_CALLBACK_SIGNERCALLBACK_INTERNALS
            .invoke_callback::<::std::result::Result<Vec<u8>, r#Error>, crate::UniFfiTag>(
                self.handle,
                1,
                args_rbuf,
            )
    }
}

::uniffi::ffi_converter_callback_interface!(
    r#SignerCallback,
    UniFFICallbackHandlerSignerCallback,
    "SignerCallback",
    crate::UniFfiTag
);

// External and Wrapped types
// Support for external types.

// Types with an external `FfiConverter`...

// For custom scaffolding types we need to generate an FfiConverter impl based on the
// UniffiCustomTypeConverter implementation that the library supplies

// Export scaffolding checksums

#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_func_version() -> u16 {
    31632
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_func_sdk_version() -> u16 {
    32199
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_reader_from_stream() -> u16 {
    50669
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_reader_from_manifest_data_and_stream() -> u16 {
    30428
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_reader_json() -> u16 {
    18261
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_reader_resource_to_stream() -> u16 {
    29142
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_with_json() -> u16 {
    29835
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_set_no_embed() -> u16 {
    46988
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_set_remote_url() -> u16 {
    25667
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_add_resource() -> u16 {
    29891
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_add_ingredient() -> u16 {
    50859
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_to_archive() -> u16 {
    6987
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_from_archive() -> u16 {
    56644
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_sign() -> u16 {
    9859
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_method_builder_sign_file() -> u16 {
    64222
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_constructor_reader_new() -> u16 {
    39952
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_constructor_callbacksigner_new() -> u16 {
    15795
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_constructor_callbacksigner_new_from_signer() -> u16 {
    25848
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_c2pa_checksum_constructor_builder_new() -> u16 {
    6168
}

// The `reexport_uniffi_scaffolding` macro
// Code to re-export the UniFFI scaffolding functions.
//
// Rust won't always re-export the functions from dependencies
// ([rust-lang#50007](https://github.com/rust-lang/rust/issues/50007))
//
// A workaround for this is to have the dependent crate reference a function from its dependency in
// an extern "C" function. This is clearly hacky and brittle, but at least we have some unittests
// that check if this works (fixtures/reexport-scaffolding-macro).
//
// The main way we use this macro is for that contain multiple UniFFI components (libxul,
// megazord).  The combined library has a cargo dependency for each component and calls
// uniffi_reexport_scaffolding!() for each one.

#[allow(missing_docs)]
#[doc(hidden)]
pub const fn uniffi_reexport_hack() {}

#[doc(hidden)]
#[macro_export]
macro_rules! uniffi_reexport_scaffolding {
    () => {
        #[doc(hidden)]
        #[no_mangle]
        pub extern "C" fn c2pa_uniffi_reexport_hack() {
            $crate::uniffi_reexport_hack()
        }
    };
}
